if(!is.null(id_order)) {
if(id_order[1] %in% c("increasing",'decreasing')){
warning("Increasing/decreasing have been deprecated as options for id_order use increasing=TRUE or increasing=FALSE instead",
call. = FALSE)
if(id_order[1]=="increasing") increasing = TRUE
if(id_order[1]=="decreasing") increasing = FALSE
id_order = NULL
}
}
df[,id] <- as.character(df[,id])
if(is.null(id_order)){
max_df <- stats::aggregate(df[,end]~df[,id],FUN=max,na.rm=T)
names(max_df) <- c(id,'MAX_TIME_FOR_EACH_ID')
if(increasing) {id_order <-  max_df[order(max_df$MAX_TIME_FOR_EACH_ID),id]
}else id_order <-  max_df[order(max_df$MAX_TIME_FOR_EACH_ID,decreasing = T),id]
}
if (id_order[1] %in% names(df)) {
max_df <- stats::aggregate(df[,end]~df[,id],FUN=max,na.rm=T)
names(max_df) <- c(id,'MAX_TIME_FOR_EACH_ID')
merged_df_with_max <- merge(max_df,df,all=F)
starting_df <-  stats::aggregate(df[,end]~df[,id],FUN=min,na.rm=T)
names(starting_df) <- c(id,end)
starting_information <- merge(starting_df,merged_df_with_max,all=F)
if(increasing) {id_order <- starting_information[order(starting_information[,id_order[1]], -rank(starting_information$MAX_TIME_FOR_EACH_ID), decreasing = TRUE),id]
}else id_order <- starting_information[order(starting_information[,id_order[1]], rank(starting_information$MAX_TIME_FOR_EACH_ID), decreasing = TRUE),id]
}
df <- df[order(df[,id],df[,end]),]
##Filling in any gaps (Adding empty bars at 0 and between sections)
if(start %in% names(df)){
##Checking there are not overlapping sections
add_in <- function(id_fix,df,start,end){
df_fix <- df[df[,id]==id_fix,]
end_blank <- df_fix[,start][c(0,dplyr::lag(df_fix[,end])[-1]) != df_fix[,start]]
start_blank <- c(0,dplyr::lag(df_fix[,end])[-1])[c(0,dplyr::lag(df_fix[,end])[-1]) != df_fix[,start]]
df_fixed <- data.frame(id_fix,start_blank,end_blank)
names(df_fixed) <- c(id,start,end)
merge(df_fixed,df_fix,all=T)
}
df <- do.call(rbind.data.frame,sapply(unique(df[,id]), add_in,df=df,start=start,end=end,simplify = F))
}else {
start = 'starting_bars_variable'
df$starting_bars_variable <- stats::ave(df[,end], df[,id], FUN=dplyr::lag)
df$starting_bars_variable[is.na(df$starting_bars_variable)] <- 0
}
temp_end <- df[,end] - stats::ave(df[,end], df[,id], FUN=dplyr::lag)
df[,end][!is.na(temp_end)] <- temp_end[!is.na(temp_end)]
df <- data.frame(df)
starting_times <- sort(unique(df[,start]),decreasing = TRUE)
df[,start] <- factor(df[,start],starting_times)
df[, id] <- factor(df[, id], levels = id_order)
plot <-
ggplot2::ggplot(df) +
ggplot2::geom_col(position = "stack",
ggplot2::aes_string(fill = name_fill,col = name_col,alpha=name_alpha, group = start,x = id, y = end),...) + ggplot2::coord_flip() +
ggplot2::theme_bw(base_size = base_size) +
ggplot2::theme(panel.grid.minor = ggplot2::element_blank(),panel.grid.major = ggplot2::element_blank())
if(stratify[1]!=FALSE) plot <-  plot + ggplot2::facet_wrap(stats::as.formula(paste("~",paste(stratify,collapse = "+"))),scales = "free_y")+
ggplot2::theme(strip.background = ggplot2::element_rect(colour="black", fill="white"))
if(identifiers==FALSE) plot <-  plot + ggplot2::theme(axis.title.y=ggplot2::element_blank(),
axis.text.y=ggplot2::element_blank(),
axis.ticks.y=ggplot2::element_blank())
return(plot)
}
test_data <- data.frame(id=c(1,1,1,2),start=c(0,2,4,3),end=c(2,3,4,5),group=c('A','C','A','B'))
swimmer_plot(test_data,name_fill = 'group')
test_data
test_data <- data.frame(id=c(1,1,1,2),start=c(0,2,4,3),end=c(2,3,7,5),group=c('A','C','A','B'))
swimmer_plot(test_data,name_fill = 'group')
test_data <- data.frame(id=c(1,1,1,2,1),start=c(0,2,4,3,1.5),end=c(2,3,7,5,2),group=c('A','C','A','B'))
test_data <- data.frame(id=c(1,1,1,2,1),start=c(0,2,4,3,1.5),end=c(2,3,7,5,2),group=c('A','C','A','B','B'))
swimmer_plot(test_data,name_fill = 'group')
start='start'
end='end'
id='id'
id='id'
start='start'
df =test_data
data
df <- data.frame(id=c(1,1,1,2,1),start=c(0,2,4,3,1.5),end=c(2,3,7,5,2),group=c('A','C','A','B','B'))
df
id
end
start
unlist(sapply(unique(treatment_data$id), check_for_overlap,start=start,end=end,data=df,id=id))
##Checking there are not overlapping sections
check_for_overlap <- function(data,id,start,end,x){
single <- data[data[,id]==x,]
if(dim(single)[1]>1){
single <- single[order(single[,start]),]
check_val <- min(single[,start]-dplyr::lag(single[,end]),na.rm = T)
if(check_val<0) return(x)
}
}
unlist(sapply(unique(treatment_data$id), check_for_overlap,start=start,end=end,data=df,id=id))
unlist(sapply(unique(df[,id]), check_for_overlap,start=start,end=end,data=df,id=id))
df <- data.frame(id=c(1,1,1,2),start=c(0,2,4,3),end=c(2,3,7,5),group=c('A','C','A','B'))
unlist(sapply(unique(df[,id]), check_for_overlap,start=start,end=end,data=df,id=id))
length(unlist(sapply(unique(df[,id]), check_for_overlap,start=start,end=end,data=df,id=id)))
overlap <- unlist(sapply(unique(df[,id]), check_for_overlap,start=start,end=end,data=df,id=id))
length(overlap)
paste0("Error:there are", length(overlap),"ids with overlap between bars, they are","(",overlap,")")
paste("Error:there are", length(overlap),"ids with overlap between bars, they are","(",overlap,")")
paste("Error:there are", length(overlap),"ids with overlap between bars, they are (",overlap,")")
df <- data.frame(id=c(1,1,1,2,1),start=c(0,2,4,3,1.5),end=c(2,3,7,5,2),group=c('A','C','A','B','B'))
overlap <- unlist(sapply(unique(df[,id]), check_for_overlap,start=start,end=end,data=df,id=id))
paste("Error:there are", length(overlap),"ids with overlap between bars, they are (",overlap,")")
df <- data.frame(id=c(1,1,1,2,1,2),start=c(0,2,4,3,2,1.5),end=c(2,3,7,5,4,2),group=c('A','C','A','B','B'))
df <- data.frame(id=c(1,1,1,2,1,2),start=c(0,2,4,3,2,1.5),end=c(2,3,7,5,4,2),group=c('A','C','A','B','H','B'))
overlap <- unlist(sapply(unique(df[,id]), check_for_overlap,start=start,end=end,data=df,id=id))
paste("Error:there is", length(overlap),"ids with overlap between bars, they are (",overlap,")")
df
df <- data.frame(id=c(1,1,1,2,1,2),start=c(0,2,4,3,2,1.5),end=c(2,3,7,5,4,5),group=c('A','C','A','B','H','B'))
overlap <- unlist(sapply(unique(df[,id]), check_for_overlap,start=start,end=end,data=df,id=id))
overlap
paste (overlap,sep="", collapse=",")
paste("Error:there is", length(overlap),"ids with overlap between bars, they are (",paste (overlap,sep="", collapse=","),")")
paste0("Error:there is", length(overlap),"ids with overlap between bars, they are (",paste (overlap,sep="", collapse=","),")")
paste0("Error:there is(are)", length(overlap),"id(s) with overlap between bars, they are (",paste (overlap,sep="", collapse=","),")")
paste0("Error:there is(are) ", length(overlap)," id(s) with overlap between bars, they are (",paste (overlap,sep="", collapse=","),")")
paste0("Error:there is(are) ", length(overlap)," id(s) with overlap between bars, they are",id ,"=(",paste (overlap,sep="", collapse=","),")")
paste0("Error:there is(are) ", length(overlap)," id(s) with overlap between bars, they are ",id ,"=(",paste (overlap,sep="", collapse=","),")")
swimmer_plot <- function(df,id='id',end='end',start='start',name_fill=NULL,name_col=NULL,name_alpha=NULL,increasing=TRUE,id_order = NULL,
stratify=FALSE,base_size=11,identifiers=TRUE,...)
{
#Check deprecated id_order = increasing or decreasing
if(!is.null(id_order)) {
if(id_order[1] %in% c("increasing",'decreasing')){
warning("Increasing/decreasing have been deprecated as options for id_order use increasing=TRUE or increasing=FALSE instead",
call. = FALSE)
if(id_order[1]=="increasing") increasing = TRUE
if(id_order[1]=="decreasing") increasing = FALSE
id_order = NULL
}
}
df[,id] <- as.character(df[,id])
if(is.null(id_order)){
max_df <- stats::aggregate(df[,end]~df[,id],FUN=max,na.rm=T)
names(max_df) <- c(id,'MAX_TIME_FOR_EACH_ID')
if(increasing) {id_order <-  max_df[order(max_df$MAX_TIME_FOR_EACH_ID),id]
}else id_order <-  max_df[order(max_df$MAX_TIME_FOR_EACH_ID,decreasing = T),id]
}
if (id_order[1] %in% names(df)) {
max_df <- stats::aggregate(df[,end]~df[,id],FUN=max,na.rm=T)
names(max_df) <- c(id,'MAX_TIME_FOR_EACH_ID')
merged_df_with_max <- merge(max_df,df,all=F)
starting_df <-  stats::aggregate(df[,end]~df[,id],FUN=min,na.rm=T)
names(starting_df) <- c(id,end)
starting_information <- merge(starting_df,merged_df_with_max,all=F)
if(increasing) {id_order <- starting_information[order(starting_information[,id_order[1]], -rank(starting_information$MAX_TIME_FOR_EACH_ID), decreasing = TRUE),id]
}else id_order <- starting_information[order(starting_information[,id_order[1]], rank(starting_information$MAX_TIME_FOR_EACH_ID), decreasing = TRUE),id]
}
df <- df[order(df[,id],df[,end]),]
##Filling in any gaps (Adding empty bars at 0 and between sections)
if(start %in% names(df)){
##Checking there are not overlapping sections
check_for_overlap <- function(data,id,start,end,x){
single <- data[data[,id]==x,]
if(dim(single)[1]>1){
single <- single[order(single[,start]),]
check_val <- min(single[,start]-dplyr::lag(single[,end]),na.rm = T)
if(check_val<0) return(x)
}
}
overlap <- unlist(sapply(unique(df[,id]), check_for_overlap,start=start,end=end,data=df,id=id))
if(length(overlap)>0) {stop(paste0(    paste0("Error:there is(are) ", length(overlap)," id(s) with overlap between bars, they are ",id ,"=(",paste (overlap,sep="", collapse=","),")")))}
add_in <- function(id_fix,df,start,end){
df_fix <- df[df[,id]==id_fix,]
end_blank <- df_fix[,start][c(0,dplyr::lag(df_fix[,end])[-1]) != df_fix[,start]]
start_blank <- c(0,dplyr::lag(df_fix[,end])[-1])[c(0,dplyr::lag(df_fix[,end])[-1]) != df_fix[,start]]
df_fixed <- data.frame(id_fix,start_blank,end_blank)
names(df_fixed) <- c(id,start,end)
merge(df_fixed,df_fix,all=T)
}
df <- do.call(rbind.data.frame,sapply(unique(df[,id]), add_in,df=df,start=start,end=end,simplify = F))
}else {
start = 'starting_bars_variable'
df$starting_bars_variable <- stats::ave(df[,end], df[,id], FUN=dplyr::lag)
df$starting_bars_variable[is.na(df$starting_bars_variable)] <- 0
}
temp_end <- df[,end] - stats::ave(df[,end], df[,id], FUN=dplyr::lag)
df[,end][!is.na(temp_end)] <- temp_end[!is.na(temp_end)]
df <- data.frame(df)
starting_times <- sort(unique(df[,start]),decreasing = TRUE)
df[,start] <- factor(df[,start],starting_times)
df[, id] <- factor(df[, id], levels = id_order)
plot <-
ggplot2::ggplot(df) +
ggplot2::geom_col(position = "stack",
ggplot2::aes_string(fill = name_fill,col = name_col,alpha=name_alpha, group = start,x = id, y = end),...) + ggplot2::coord_flip() +
ggplot2::theme_bw(base_size = base_size) +
ggplot2::theme(panel.grid.minor = ggplot2::element_blank(),panel.grid.major = ggplot2::element_blank())
if(stratify[1]!=FALSE) plot <-  plot + ggplot2::facet_wrap(stats::as.formula(paste("~",paste(stratify,collapse = "+"))),scales = "free_y")+
ggplot2::theme(strip.background = ggplot2::element_rect(colour="black", fill="white"))
if(identifiers==FALSE) plot <-  plot + ggplot2::theme(axis.title.y=ggplot2::element_blank(),
axis.text.y=ggplot2::element_blank(),
axis.ticks.y=ggplot2::element_blank())
return(plot)
}
df <- data.frame(id=c(1,1,1,2),start=c(0,2,4,3),end=c(2,3,7,5),group=c('A','C','A','B'))
swimmer_plot(test_data,name_fill = 'group')
df <- data.frame(id=c(1,1,1),start=c(0,2,4),end=c(2,3,7),group=c('A','C','A'))
swimmer_plot(test_data,name_fill = 'group')
df
overlap <- unlist(sapply(unique(df[,id]), check_for_overlap,start=start,end=end,data=df,id=id))
overlap
length(overlap)
df <- data.frame(id=c(1,1,1),start=c(0,2,4),end=c(2,3,7),group=c('A','C','A'))
swimmer_plot(df,name_fill = 'group')
df <- data.frame(id=c(1,1,1,2,1,2),start=c(0,2,4,3,2,1.5),end=c(2,3,7,5,4,5),group=c('A','C','A','B','H','B'))
swimmer_plot(df,name_fill = 'group')
df <- data.frame('name'=c('Jess','Jess','Jess','TT','Jess','TT'),begining=c(0,2,4,3,2,1.5),stop=c(2,3,7,5,4,5),group=c('A','C','A','B','H','B'))
swimmer_plot(df,name_fill = 'group',id=,end=,start=)
swimmer_plot(df,name_fill = 'group',id='name',end='stop',start='begining')
swimmer_plot <- function(df,id='id',end='end',start='start',name_fill=NULL,name_col=NULL,name_alpha=NULL,increasing=TRUE,id_order = NULL,
stratify=FALSE,base_size=11,identifiers=TRUE,...)
{
#Check deprecated id_order = increasing or decreasing
if(!is.null(id_order)) {
if(id_order[1] %in% c("increasing",'decreasing')){
warning("Increasing/decreasing have been deprecated as options for id_order use increasing=TRUE or increasing=FALSE instead",
call. = FALSE)
if(id_order[1]=="increasing") increasing = TRUE
if(id_order[1]=="decreasing") increasing = FALSE
id_order = NULL
}
}
df[,id] <- as.character(df[,id])
if(is.null(id_order)){
max_df <- stats::aggregate(df[,end]~df[,id],FUN=max,na.rm=T)
names(max_df) <- c(id,'MAX_TIME_FOR_EACH_ID')
if(increasing) {id_order <-  max_df[order(max_df$MAX_TIME_FOR_EACH_ID),id]
}else id_order <-  max_df[order(max_df$MAX_TIME_FOR_EACH_ID,decreasing = T),id]
}
if (id_order[1] %in% names(df)) {
max_df <- stats::aggregate(df[,end]~df[,id],FUN=max,na.rm=T)
names(max_df) <- c(id,'MAX_TIME_FOR_EACH_ID')
merged_df_with_max <- merge(max_df,df,all=F)
starting_df <-  stats::aggregate(df[,end]~df[,id],FUN=min,na.rm=T)
names(starting_df) <- c(id,end)
starting_information <- merge(starting_df,merged_df_with_max,all=F)
if(increasing) {id_order <- starting_information[order(starting_information[,id_order[1]], -rank(starting_information$MAX_TIME_FOR_EACH_ID), decreasing = TRUE),id]
}else id_order <- starting_information[order(starting_information[,id_order[1]], rank(starting_information$MAX_TIME_FOR_EACH_ID), decreasing = TRUE),id]
}
df <- df[order(df[,id],df[,end]),]
##Filling in any gaps (Adding empty bars at 0 and between sections)
if(start %in% names(df)){
##Checking there are not overlapping sections
check_for_overlap <- function(data,id,start,end,x){
single <- data[data[,id]==x,]
if(dim(single)[1]>1){
single <- single[order(single[,start]),]
check_val <- min(single[,start]-dplyr::lag(single[,end]),na.rm = T)
if(check_val<0) return(x)
}
}
overlap <- unlist(sapply(unique(df[,id]), check_for_overlap,start=start,end=end,data=df,id=id))
if(length(overlap)>0) {stop(paste0(    paste0("There is(are) ", length(overlap)," id(s) with overlap between bars, they are ",id ,"=(",paste (overlap,sep="", collapse=","),")")))}
add_in <- function(id_fix,df,start,end){
df_fix <- df[df[,id]==id_fix,]
end_blank <- df_fix[,start][c(0,dplyr::lag(df_fix[,end])[-1]) != df_fix[,start]]
start_blank <- c(0,dplyr::lag(df_fix[,end])[-1])[c(0,dplyr::lag(df_fix[,end])[-1]) != df_fix[,start]]
df_fixed <- data.frame(id_fix,start_blank,end_blank)
names(df_fixed) <- c(id,start,end)
merge(df_fixed,df_fix,all=T)
}
df <- do.call(rbind.data.frame,sapply(unique(df[,id]), add_in,df=df,start=start,end=end,simplify = F))
}else {
start = 'starting_bars_variable'
df$starting_bars_variable <- stats::ave(df[,end], df[,id], FUN=dplyr::lag)
df$starting_bars_variable[is.na(df$starting_bars_variable)] <- 0
}
temp_end <- df[,end] - stats::ave(df[,end], df[,id], FUN=dplyr::lag)
df[,end][!is.na(temp_end)] <- temp_end[!is.na(temp_end)]
df <- data.frame(df)
starting_times <- sort(unique(df[,start]),decreasing = TRUE)
df[,start] <- factor(df[,start],starting_times)
df[, id] <- factor(df[, id], levels = id_order)
plot <-
ggplot2::ggplot(df) +
ggplot2::geom_col(position = "stack",
ggplot2::aes_string(fill = name_fill,col = name_col,alpha=name_alpha, group = start,x = id, y = end),...) + ggplot2::coord_flip() +
ggplot2::theme_bw(base_size = base_size) +
ggplot2::theme(panel.grid.minor = ggplot2::element_blank(),panel.grid.major = ggplot2::element_blank())
if(stratify[1]!=FALSE) plot <-  plot + ggplot2::facet_wrap(stats::as.formula(paste("~",paste(stratify,collapse = "+"))),scales = "free_y")+
ggplot2::theme(strip.background = ggplot2::element_rect(colour="black", fill="white"))
if(identifiers==FALSE) plot <-  plot + ggplot2::theme(axis.title.y=ggplot2::element_blank(),
axis.text.y=ggplot2::element_blank(),
axis.ticks.y=ggplot2::element_blank())
return(plot)
}
df <- data.frame(id=c(1,1,1),start=c(0,2,4),end=c(2,3,7),group=c('A','C','A'))
swimmer_plot(df,name_fill = 'group',id='name',end='stop',start='begining')
df <- data.frame('name'=c('Jess','Jess','Jess','TT','Jess','TT'),begining=c(0,2,4,3,2,1.5),stop=c(2,3,7,5,4,5),group=c('A','C','A','B','H','B'))
swimmer_plot(df,name_fill = 'group',id='name',end='stop',start='begining')
##Removing rows that start before 0
data[,id][data[,start]]<0
##Removing rows that start before 0
df[,id][df[,start]]<0
df[,id]
id
df <- data.frame(id=c(1,1,1),start=c(0,2,4),end=c(2,3,7),group=c('A','C','A'))
df <- data.frame(id=c(1,1,1,2),start=c(0,2,4,-1),end=c(2,3,7,6),group=c('A','C','A'))
df <- data.frame(id=c(1,1,1,2),start=c(0,2,4,-1),end=c(2,3,7,6),group=c('A','C','A','S'))
swimmer_plot(df,name_fill = 'group',id='name',end='stop',start='begining')
swimmer_plot(df,name_fill = 'group')
##Removing rows that start before 0
df[,id][df[,start]]<0
df[,id]
df[,start]<0
##Removing rows that start before 0
df[,id][df[,start]<0]
if(length(negative_start)>0) {stop(paste0(    paste0("There is(are) ", length(overlap)," id(s) that have negative start times",id ,"=(",paste (negative_start,sep="", collapse=","),")")))}
##Removing rows that start before 0
negative_start <- df[,id][df[,start]<0]
if(length(negative_start)>0) {stop(paste0(    paste0("There is(are) ", length(overlap)," id(s) that have negative start times",id ,"=(",paste (negative_start,sep="", collapse=","),")")))}
if(length(negative_start)>0) {stop(paste0(    paste0("There is(are) ", length(negative_start)," id(s) that have negative start times",id ,"=(",paste (negative_start,sep="", collapse=","),")")))}
if(length(negative_start)>0) {stop(paste0(    paste0("There is(are) ", length(negative_start)," id(s) that have negative start times ",id ,"=(",paste (negative_start,sep="", collapse=","),")")))}
swimmer_plot <- function(df,id='id',end='end',start='start',name_fill=NULL,name_col=NULL,name_alpha=NULL,increasing=TRUE,id_order = NULL,
stratify=FALSE,base_size=11,identifiers=TRUE,...)
{
#Check deprecated id_order = increasing or decreasing
if(!is.null(id_order)) {
if(id_order[1] %in% c("increasing",'decreasing')){
warning("Increasing/decreasing have been deprecated as options for id_order use increasing=TRUE or increasing=FALSE instead",
call. = FALSE)
if(id_order[1]=="increasing") increasing = TRUE
if(id_order[1]=="decreasing") increasing = FALSE
id_order = NULL
}
}
df[,id] <- as.character(df[,id])
if(is.null(id_order)){
max_df <- stats::aggregate(df[,end]~df[,id],FUN=max,na.rm=T)
names(max_df) <- c(id,'MAX_TIME_FOR_EACH_ID')
if(increasing) {id_order <-  max_df[order(max_df$MAX_TIME_FOR_EACH_ID),id]
}else id_order <-  max_df[order(max_df$MAX_TIME_FOR_EACH_ID,decreasing = T),id]
}
if (id_order[1] %in% names(df)) {
max_df <- stats::aggregate(df[,end]~df[,id],FUN=max,na.rm=T)
names(max_df) <- c(id,'MAX_TIME_FOR_EACH_ID')
merged_df_with_max <- merge(max_df,df,all=F)
starting_df <-  stats::aggregate(df[,end]~df[,id],FUN=min,na.rm=T)
names(starting_df) <- c(id,end)
starting_information <- merge(starting_df,merged_df_with_max,all=F)
if(increasing) {id_order <- starting_information[order(starting_information[,id_order[1]], -rank(starting_information$MAX_TIME_FOR_EACH_ID), decreasing = TRUE),id]
}else id_order <- starting_information[order(starting_information[,id_order[1]], rank(starting_information$MAX_TIME_FOR_EACH_ID), decreasing = TRUE),id]
}
df <- df[order(df[,id],df[,end]),]
##Filling in any gaps (Adding empty bars at 0 and between sections)
if(start %in% names(df)){
##Removing rows that start before 0
negative_start <- df[,id][df[,start]<0]
if(length(negative_start)>0) {stop(paste0(    paste0("There is(are) ", length(negative_start)," id(s) that have negative start times ",id ,"=(",paste (negative_start,sep="", collapse=","),")")))}
##Checking there are not overlapping sections
check_for_overlap <- function(data,id,start,end,x){
single <- data[data[,id]==x,]
if(dim(single)[1]>1){
single <- single[order(single[,start]),]
check_val <- min(single[,start]-dplyr::lag(single[,end]),na.rm = T)
if(check_val<0) return(x)
}
}
overlap <- unlist(sapply(unique(df[,id]), check_for_overlap,start=start,end=end,data=df,id=id))
if(length(overlap)>0) {stop(paste0(    paste0("There is(are) ", length(overlap)," id(s) with overlap between bars, they are ",id ,"=(",paste (overlap,sep="", collapse=","),")")))}
add_in <- function(id_fix,df,start,end){
df_fix <- df[df[,id]==id_fix,]
end_blank <- df_fix[,start][c(0,dplyr::lag(df_fix[,end])[-1]) != df_fix[,start]]
start_blank <- c(0,dplyr::lag(df_fix[,end])[-1])[c(0,dplyr::lag(df_fix[,end])[-1]) != df_fix[,start]]
df_fixed <- data.frame(id_fix,start_blank,end_blank)
names(df_fixed) <- c(id,start,end)
merge(df_fixed,df_fix,all=T)
}
df <- do.call(rbind.data.frame,sapply(unique(df[,id]), add_in,df=df,start=start,end=end,simplify = F))
}else {
start = 'starting_bars_variable'
df$starting_bars_variable <- stats::ave(df[,end], df[,id], FUN=dplyr::lag)
df$starting_bars_variable[is.na(df$starting_bars_variable)] <- 0
}
temp_end <- df[,end] - stats::ave(df[,end], df[,id], FUN=dplyr::lag)
df[,end][!is.na(temp_end)] <- temp_end[!is.na(temp_end)]
df <- data.frame(df)
starting_times <- sort(unique(df[,start]),decreasing = TRUE)
df[,start] <- factor(df[,start],starting_times)
df[, id] <- factor(df[, id], levels = id_order)
plot <-
ggplot2::ggplot(df) +
ggplot2::geom_col(position = "stack",
ggplot2::aes_string(fill = name_fill,col = name_col,alpha=name_alpha, group = start,x = id, y = end),...) + ggplot2::coord_flip() +
ggplot2::theme_bw(base_size = base_size) +
ggplot2::theme(panel.grid.minor = ggplot2::element_blank(),panel.grid.major = ggplot2::element_blank())
if(stratify[1]!=FALSE) plot <-  plot + ggplot2::facet_wrap(stats::as.formula(paste("~",paste(stratify,collapse = "+"))),scales = "free_y")+
ggplot2::theme(strip.background = ggplot2::element_rect(colour="black", fill="white"))
if(identifiers==FALSE) plot <-  plot + ggplot2::theme(axis.title.y=ggplot2::element_blank(),
axis.text.y=ggplot2::element_blank(),
axis.ticks.y=ggplot2::element_blank())
return(plot)
}
swimmer_plot(df,name_fill = 'group',id='name',end='stop',start='begining')
df <- data.frame(id=c(1,1,1,2),start=c(0,2,4,-1),end=c(2,3,7,6),group=c('A','C','A','S'))
swimmer_plot(df,name_fill = 'group')
install.packages('dlstats')
library("ggplot2")
library("dlstats")
x <- cran_stats(c("emojifont", "ggimage", "hexSticker", "rvcheck"))
if (!is.null(x)) {
head(x)
ggplot(x, aes(end, downloads, group=package, color=package)) +
geom_line() + geom_point(aes(shape=package))
}
cran_stats('swimplot')
?cran_stats
dlstats::cran_stats('swimplot')
a <- dlstats::cran_stats('swimplot')
a$downloads
sum(dlstats::cran_stats('swimplot')$downloads)
dlstats::cran_stats('hexSticker')
sum(dlstats::cran_stats('hexSticker')$downloads)
sum(dlstats::cran_stats('swimplot')$downloads)
dlstats::cran_stats('swimplot')
sum(dlstats::cran_stats('swimplot')$downloads)
swimmer_plot <- function(df,id='id',end='end',start='start',name_fill=NULL,name_col=NULL,name_alpha=NULL,increasing=TRUE,id_order = NULL,
stratify=FALSE,base_size=11,identifiers=TRUE,...)
{
#Check deprecated id_order = increasing or decreasing
if(!is.null(id_order)) {
if(id_order[1] %in% c("increasing",'decreasing')){
warning("Increasing/decreasing have been deprecated as options for id_order use increasing=TRUE or increasing=FALSE instead",
call. = FALSE)
if(id_order[1]=="increasing") increasing = TRUE
if(id_order[1]=="decreasing") increasing = FALSE
id_order = NULL
}
}
df[,id] <- as.character(df[,id])
if(is.null(id_order)){
max_df <- stats::aggregate(df[,end]~df[,id],FUN=max,na.rm=T)
names(max_df) <- c(id,'MAX_TIME_FOR_EACH_ID')
if(increasing) {id_order <-  max_df[order(max_df$MAX_TIME_FOR_EACH_ID),id]
}else id_order <-  max_df[order(max_df$MAX_TIME_FOR_EACH_ID,decreasing = T),id]
}
if (id_order[1] %in% names(df)) {
max_df <- stats::aggregate(df[,end]~df[,id],FUN=max,na.rm=T)
names(max_df) <- c(id,'MAX_TIME_FOR_EACH_ID')
merged_df_with_max <- merge(max_df,df,all=F)
starting_df <-  stats::aggregate(df[,end]~df[,id],FUN=min,na.rm=T)
names(starting_df) <- c(id,end)
starting_information <- merge(starting_df,merged_df_with_max,all=F)
if(increasing) {id_order <- starting_information[order(starting_information[,id_order[1]], -rank(starting_information$MAX_TIME_FOR_EACH_ID), decreasing = TRUE),id]
}else id_order <- starting_information[order(starting_information[,id_order[1]], rank(starting_information$MAX_TIME_FOR_EACH_ID), decreasing = TRUE),id]
}
df <- df[order(df[,id],df[,end]),]
##Filling in any gaps (Adding empty bars at 0 and between sections)
if(start %in% names(df)){
##Removing rows that start before 0
negative_start <- df[,id][df[,start]<0]
if(length(negative_start)>0) {stop(paste0(    paste0("There is(are) ", length(negative_start)," id(s) that have negative start times ",id ,"=(",paste (negative_start,sep="", collapse=","),")")))}
##Checking there are not overlapping sections
check_for_overlap <- function(data,id,start,end,x){
single <- data[data[,id]==x,]
if(dim(single)[1]>1){
single <- single[order(single[,start]),]
check_val <- min(single[,start]-dplyr::lag(single[,end]),na.rm = T)
if(check_val<0) return(x)
}
}
overlap <- unlist(sapply(unique(df[,id]), check_for_overlap,start=start,end=end,data=df,id=id))
if(length(overlap)>0) {stop(paste0(    paste0("There is(are) ", length(overlap)," id(s) with overlap between bars, they are ",id ,"=(",paste (overlap,sep="", collapse=","),")")))}
add_in <- function(id_fix,df,start,end){
df_fix <- df[df[,id]==id_fix,]
end_blank <- df_fix[,start][c(0,dplyr::lag(df_fix[,end])[-1]) != df_fix[,start]]
start_blank <- c(0,dplyr::lag(df_fix[,end])[-1])[c(0,dplyr::lag(df_fix[,end])[-1]) != df_fix[,start]]
df_fixed <- data.frame(id_fix,start_blank,end_blank)
names(df_fixed) <- c(id,start,end)
merge(df_fixed,df_fix,all=T)
}
df <- do.call(rbind.data.frame,sapply(unique(df[,id]), add_in,df=df,start=start,end=end,simplify = F))
}else {
start = 'starting_bars_variable'
df$starting_bars_variable <- stats::ave(df[,end], df[,id], FUN=dplyr::lag)
df$starting_bars_variable[is.na(df$starting_bars_variable)] <- 0
}
temp_end <- df[,end] - stats::ave(df[,end], df[,id], FUN=dplyr::lag)
df[,end][!is.na(temp_end)] <- temp_end[!is.na(temp_end)]
df <- data.frame(df)
starting_times <- sort(unique(df[,start]),decreasing = TRUE)
df[,start] <- factor(df[,start],starting_times)
df[, id] <- factor(df[, id], levels = id_order)
plot <-
ggplot2::ggplot(df) +
ggplot2::geom_col(position = "stack",
ggplot2::aes_string(fill = name_fill,col = name_col,alpha=name_alpha, group = start,x = id, y = end),...) + ggplot2::coord_flip() +
ggplot2::theme_bw(base_size = base_size) +
ggplot2::theme(panel.grid.minor = ggplot2::element_blank(),panel.grid.major = ggplot2::element_blank())
if(stratify[1]!=FALSE) plot <-  plot + ggplot2::facet_wrap(stats::as.formula(paste("~",paste(stratify,collapse = "+"))),scales = "free_y")+
ggplot2::theme(strip.background = ggplot2::element_rect(colour="black", fill="white"))
if(identifiers==FALSE) plot <-  plot + ggplot2::theme(axis.title.y=ggplot2::element_blank(),
axis.text.y=ggplot2::element_blank(),
axis.ticks.y=ggplot2::element_blank())
return(plot)
}
treatment_data$start_time[treatment_data$id==124 & treatment_data$treatment=="Alectinib"]
treatment_data$start_time[treatment_data$id==124 & treatment_data$treatment=="Alectinib"] = 0.08743169
load("T:/Dept Staff Members/Jessica/Projects/Lung group/Geoffrey Liu/Sierra/swimplot/treatment_data.RData")
treatment_data$start_time[treatment_data$id==124 & treatment_data$treatment=="Alectinib"]
treatment_data$start_time[treatment_data$id==124 & treatment_data$treatment=="Alectinib"] = 0.08743169
library(RColorBrewer)
swimmer_plot(df=treatment_data,id="id",name_fill="treatment",start="start_time",end="end_time", col=1) +
ggplot2::scale_fill_brewer(palette = "Set3",na.value=NA)
swimmer_plot(df=treatment_data[!treatment_data$id %in% 24,],id="id",name_fill="treatment",start="start_time",end="end_time", col=1) +
ggplot2::scale_fill_brewer(palette = "Set3",na.value=NA)
swimmer_plot(df=treatment_data[!treatment_data$id %in% c(24,119,124,38,72),],id="id",name_fill="treatment",start="start_time",end="end_time", col=1) +
ggplot2::scale_fill_brewer(palette = "Set3",na.value=NA)
