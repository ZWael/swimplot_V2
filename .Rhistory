df$ID_FOR_ALPHA <- df[,id]
name_alpha = 'ID_FOR_ALPHA'
}
if(name_alpha==start) {
df$START_FOR_ALPHA <- df[,start]
name_alpha = 'START_FOR_ALPHA'
}
if(name_alpha==end) {
df$END_FOR_ALPHA <- df[,end]
name_alpha = 'END_FOR_ALPHA'
}
}
###
#Check deprecated id_order = increasing or decreasing
if(!is.null(id_order)) {
if(id_order[1] %in% c("increasing",'decreasing')){
warning("Increasing/decreasing have been deprecated as options for id_order use increasing=TRUE or increasing=FALSE instead",
call. = FALSE)
if(id_order[1]=="increasing") increasing = TRUE
if(id_order[1]=="decreasing") increasing = FALSE
id_order = NULL
}
}
df[,id] <- as.character(df[,id])
##Putting in order by increasing or decreasing if a column name/ id order is not given
if(is.null(id_order)){
max_df <- stats::aggregate(df[,end]~df[,id],FUN=max,na.rm=T)
names(max_df) <- c(id,'MAX_TIME_FOR_EACH_ID')
if(increasing) {
id_order <-  max_df[order(max_df$MAX_TIME_FOR_EACH_ID),id]
}else id_order <-  max_df[order(max_df$MAX_TIME_FOR_EACH_ID,decreasing = T),id]
#Will also sort by the start times
if(start %in% names(df)) {
min_df <- stats::aggregate(df[,start]~df[,id],FUN=min,na.rm=T)
names(min_df) <- c(id,'MIN_TIME_FOR_EACH_ID')
max_df <- merge(max_df,min_df,all=T)
if(increasing) {id_order <-  max_df[order(max_df$MAX_TIME_FOR_EACH_ID,max_df$MIN_TIME_FOR_EACH_ID),id]
}else id_order <-  max_df[order(max_df$MAX_TIME_FOR_EACH_ID,max_df$MIN_TIME_FOR_EACH_ID,decreasing = T),id]
}
}else if (id_order[1] %in% names(df)) {
max_df <- stats::aggregate(df[,end]~df[,id],FUN=max,na.rm=T)
names(max_df) <- c(id,'MAX_TIME_FOR_EACH_ID')
merged_df_with_max <- merge(max_df,df,all=F)
starting_df <-  stats::aggregate(df[,end]~df[,id],FUN=min,na.rm=T)
names(starting_df) <- c(id,end)
starting_information <- merge(starting_df,merged_df_with_max,all=F)
if(increasing) {id_order <- starting_information[order(starting_information[,id_order[1]], -rank(starting_information$MAX_TIME_FOR_EACH_ID), decreasing = TRUE),id]
}else id_order <- starting_information[order(starting_information[,id_order[1]], rank(starting_information$MAX_TIME_FOR_EACH_ID), decreasing = TRUE),id]
}
df <- df[order(df[,id],df[,end]),]
#If the start time is given a test for overlap is done
#Sections are filled in where needed (Between bars, up to zero, before zero)
if(start %in% names(df)){
##Checking there are not overlapping sections
check_for_overlap <- function(data,id,start,end,x){
single <- data[data[,id]==x,]
if(dim(single)[1]>1){
single <- single[order(single[,start]),]
check_val <- min(single[,start]-dplyr::lag(single[,end]),na.rm = T)
if(check_val<0) return(x)
}
}
overlap <- unlist(sapply(unique(df[,id]), check_for_overlap,start=start,end=end,data=df,id=id))
if(length(overlap)>0) {stop(paste0(    paste0("There is(are) ", length(overlap)," id(s) with overlap between bars, they are ",id ,"=(",paste (overlap,sep="", collapse=","),")")))}
add_in <- function(id_fix,df,start,end){
df_fix <- df[df[,id]==id_fix,]
##Filling in space up to 0
if(max(df_fix[,end])<0){
df_fixed <- data.frame(id_fix,max(df_fix[,end]),0)
names(df_fixed) <- c(id,start,end,stratify)
if(!is.null(stratify)){
df_fixed <- data.frame(id_fix,max(df_fix[,end]),0,df_fix[,stratify])
names(df_fixed) <- c(id,start,end,stratify)
}
df_fix <- merge(df_fixed,df_fix,all=T)
}
#Starting bar at 0
start_time_pat <- 0
#If the bar starts before 0 that is okay too
if(min(df_fix[,start])<0) start_time_pat <- min(df_fix[,start])
#Looking the start times which do not meet the last end time these will be the end times of the filler sections
end_blank <- df_fix[,start][c(start_time_pat,dplyr::lag(df_fix[,end])[-1]) != df_fix[,start]]
if(length(end_blank)==0) return(df_fix) # IF no filler done
##start times of the filler are the previous end time
start_blank <- c(start_time_pat,dplyr::lag(df_fix[,end])[-1])[c(start_time_pat,dplyr::lag(df_fix[,end])[-1]) != df_fix[,start]]
df_fixed <- data.frame(id_fix,start_blank,end_blank)
names(df_fixed) <- c(id,start,end)
if(!is.null(stratify)){
df_fixed <- data.frame(id_fix,start_blank,end_blank,df_fix[,stratify])
names(df_fixed) <- c(id,start,end,stratify)
}
return(merge(df_fixed,df_fix,all=T))
}
df <- do.call(rbind.data.frame,sapply(unique(df[,id]), add_in,df=df,start=start,end=end,simplify = F))
##Fixing sections that cross 0
cross_zero <- function(i,df=df,start,end){
df_fix <- df[i,]
if(df_fix[,start]<0 & df_fix[,end]>0){
df_fix <- rbind(df_fix,df_fix)
df_fix[1,end] <- 0
df_fix[2,start] <- 0
}
return(df_fix)
}
df <- do.call(rbind.data.frame,sapply(seq_along(df[,start]), cross_zero,df=df,start=start,end=end,simplify = F))
}else {
start = 'starting_bars_variable'
df$starting_bars_variable <- stats::ave(df[,end], df[,id], FUN=dplyr::lag)
df$starting_bars_variable[is.na(df$starting_bars_variable)] <- 0
}
#Calculating the length of the bar for that section
temp_end <- df[,end] - as.numeric(as.character(df[,start]))
#Sections that are negative have to have a negative length
temp_end[as.numeric(as.character(df[,start]))<0] <- 0 - temp_end[as.numeric(as.character(df[,start]))<0]
#This column is the length of the bar section. The end column name is used so the x axis has the correct label
df[,end] <- temp_end
df <- data.frame(df)
starting_times <- sort(unique(df[,start]),decreasing = TRUE)
##Negative times need to be in backwards order to stack properly
starting_times[starting_times<0] <- rev(starting_times[starting_times<0])
df[,start] <- factor(df[,start],starting_times)
df[, id] <- factor(df[, id], levels = id_order)
plot <-
ggplot2::ggplot(df) +
ggplot2::geom_col(position = "stack",
ggplot2::aes_string(fill = name_fill,col = name_col,alpha=name_alpha, group = start,x = id, y = end),...) + ggplot2::coord_flip() +
ggplot2::theme_bw(base_size = base_size) +
ggplot2::theme(panel.grid.minor = ggplot2::element_blank(),panel.grid.major = ggplot2::element_blank())
if(!is.null(stratify)) plot <-  plot + ggplot2::facet_wrap(stats::as.formula(paste("~",paste(stratify,collapse = "+"))),scales = "free_y")+
ggplot2::theme(strip.background = ggplot2::element_rect(colour="black", fill="white"))
if(identifiers==FALSE) plot <-  plot + ggplot2::theme(axis.title.y=ggplot2::element_blank(),
axis.text.y=ggplot2::element_blank(),
axis.ticks.y=ggplot2::element_blank())
return(plot)
}
##PLAYING WITH THE ORDER
df <- data.frame(id=c("A","B","C","D","E"),start=c(-5,-4,-3,-2,-1),end=c(-1,-1,-1,-1,-0.5),
col=c(1,1,3,2,2),E=c(1,2,3,4,5))
##PLAYING WITH STRATIFYING
swimmer_plot(df,name_fill='col',id_order=c("A","B","E","C","D"))
swimmer_plot(df,name_fill='col',id_order=c("A","B","E","C","D"),stratify = 'col')
#'end=c(-3,-1,0,-2,-4,-1,3,-3,6,5,6,7,5,8,12),
#'Dose=c(10,30,10,20,20,20,30,5,5,12,18,22,30,20,10))
#'swimmer_plot(negative_data,name_fill = 'Dose',alpha=0.9)+
#'  ggplot2::theme_bw()+
#'  ggplot2::geom_hline(yintercept = 0,lwd=2,col='red') +
#'  ggplot2::scale_fill_gradient(low = "grey90", high = "grey10", na.value = NA)+
#'  ggplot2::scale_y_continuous(breaks=c(-6:15))
#'
#'
#' @export
swimmer_plot <- function(df,id='id',end='end',start='start',name_fill=NULL,name_col=NULL,name_alpha=NULL,
increasing=TRUE,id_order = NULL,
stratify=NULL,base_size=11,identifiers=TRUE,...)
{
if(!is.null(stratify))  {
if(any(duplicated(unique(df[,c(id,stratify)])[,id]))){
warning("Can not stratify when ids are in multiple strata")
stratify=NULL
}}
#Not letting the name_fill be id,start or end
if(!is.null(name_fill)){
if( name_fill==id) {
df$ID_FOR_FILL <- df[,id]
name_fill = 'ID_FOR_FILL'
}
if(name_fill==start) {
df$START_FOR_FILL <- df[,start]
name_fill = 'START_FOR_FILL'
}
if(name_fill==end) {
df$END_FOR_FILL <- df[,end]
name_fill = 'END_FOR_FILL'
}
}
#Not letting the name_col be id,start or end
if(!is.null(name_col)){
if(name_col==id) {
df$ID_FOR_COL <- df[,id]
name_col = 'ID_FOR_COL'
}
if(name_col==start) {
df$START_FOR_COL <- df[,start]
name_col = 'START_FOR_COL'
}
if(name_col==end) {
df$END_FOR_COL <- df[,end]
name_col = 'END_FOR_COL'
}
}
#Not letting the name_alpha be id,start or end
if(!is.null(name_alpha)){
if(name_alpha==id) {
df$ID_FOR_ALPHA <- df[,id]
name_alpha = 'ID_FOR_ALPHA'
}
if(name_alpha==start) {
df$START_FOR_ALPHA <- df[,start]
name_alpha = 'START_FOR_ALPHA'
}
if(name_alpha==end) {
df$END_FOR_ALPHA <- df[,end]
name_alpha = 'END_FOR_ALPHA'
}
}
###
#Check deprecated id_order = increasing or decreasing
if(!is.null(id_order)) {
if(id_order[1] %in% c("increasing",'decreasing')){
warning("Increasing/decreasing have been deprecated as options for id_order use increasing=TRUE or increasing=FALSE instead",
call. = FALSE)
if(id_order[1]=="increasing") increasing = TRUE
if(id_order[1]=="decreasing") increasing = FALSE
id_order = NULL
}
}
df[,id] <- as.character(df[,id])
##Putting in order by increasing or decreasing if a column name/ id order is not given
if(is.null(id_order)){
max_df <- stats::aggregate(df[,end]~df[,id],FUN=max,na.rm=T)
names(max_df) <- c(id,'MAX_TIME_FOR_EACH_ID')
if(increasing) {
id_order <-  max_df[order(max_df$MAX_TIME_FOR_EACH_ID),id]
}else id_order <-  max_df[order(max_df$MAX_TIME_FOR_EACH_ID,decreasing = T),id]
#Will also sort by the start times
if(start %in% names(df)) {
min_df <- stats::aggregate(df[,start]~df[,id],FUN=min,na.rm=T)
names(min_df) <- c(id,'MIN_TIME_FOR_EACH_ID')
max_df <- merge(max_df,min_df,all=T)
if(increasing) {id_order <-  max_df[order(max_df$MAX_TIME_FOR_EACH_ID,max_df$MIN_TIME_FOR_EACH_ID),id]
}else id_order <-  max_df[order(max_df$MAX_TIME_FOR_EACH_ID,max_df$MIN_TIME_FOR_EACH_ID,decreasing = T),id]
}
}else if (id_order[1] %in% names(df)) {
max_df <- stats::aggregate(df[,end]~df[,id],FUN=max,na.rm=T)
names(max_df) <- c(id,'MAX_TIME_FOR_EACH_ID')
merged_df_with_max <- merge(max_df,df,all=F)
starting_df <-  stats::aggregate(df[,end]~df[,id],FUN=min,na.rm=T)
names(starting_df) <- c(id,end)
starting_information <- merge(starting_df,merged_df_with_max,all=F)
if(increasing) {id_order <- starting_information[order(starting_information[,id_order[1]], -rank(starting_information$MAX_TIME_FOR_EACH_ID), decreasing = TRUE),id]
}else id_order <- starting_information[order(starting_information[,id_order[1]], rank(starting_information$MAX_TIME_FOR_EACH_ID), decreasing = TRUE),id]
}
df <- df[order(df[,id],df[,end]),]
#If the start time is given a test for overlap is done
#Sections are filled in where needed (Between bars, up to zero, before zero)
if(start %in% names(df)){
##Checking there are not overlapping sections
check_for_overlap <- function(data,id,start,end,x){
single <- data[data[,id]==x,]
if(dim(single)[1]>1){
single <- single[order(single[,start]),]
check_val <- min(single[,start]-dplyr::lag(single[,end]),na.rm = T)
if(check_val<0) return(x)
}
}
overlap <- unlist(sapply(unique(df[,id]), check_for_overlap,start=start,end=end,data=df,id=id))
if(length(overlap)>0) {stop(paste0(    paste0("There is(are) ", length(overlap)," id(s) with overlap between bars, they are ",id ,"=(",paste (overlap,sep="", collapse=","),")")))}
add_in <- function(id_fix,df,start,end){
df_fix <- df[df[,id]==id_fix,]
##Filling in space up to 0
if(max(df_fix[,end])<0){
if(!is.null(stratify)){
df_fixed <- data.frame(id_fix,max(df_fix[,end]),0,df_fix[,stratify])
names(df_fixed) <- c(id,start,end,stratify)
}else{
df_fixed <- data.frame(id_fix,max(df_fix[,end]),0)
names(df_fixed) <- c(id,start,end)
}
df_fix <- merge(df_fixed,df_fix,all=T)
}
#Starting bar at 0
start_time_pat <- 0
#If the bar starts before 0 that is okay too
if(min(df_fix[,start])<0) start_time_pat <- min(df_fix[,start])
#Looking the start times which do not meet the last end time these will be the end times of the filler sections
end_blank <- df_fix[,start][c(start_time_pat,dplyr::lag(df_fix[,end])[-1]) != df_fix[,start]]
if(length(end_blank)==0) return(df_fix) # IF no filler done
##start times of the filler are the previous end time
start_blank <- c(start_time_pat,dplyr::lag(df_fix[,end])[-1])[c(start_time_pat,dplyr::lag(df_fix[,end])[-1]) != df_fix[,start]]
if(!is.null(stratify)){
df_fixed <- data.frame(id_fix,start_blank,end_blank,df_fix[,stratify])
names(df_fixed) <- c(id,start,end,stratify)
}else{
df_fixed <- data.frame(id_fix,start_blank,end_blank)
names(df_fixed) <- c(id,start,end)
}
return(merge(df_fixed,df_fix,all=T))
}
df <- do.call(rbind.data.frame,sapply(unique(df[,id]), add_in,df=df,start=start,end=end,simplify = F))
##Fixing sections that cross 0
cross_zero <- function(i,df=df,start,end){
df_fix <- df[i,]
if(df_fix[,start]<0 & df_fix[,end]>0){
df_fix <- rbind(df_fix,df_fix)
df_fix[1,end] <- 0
df_fix[2,start] <- 0
}
return(df_fix)
}
df <- do.call(rbind.data.frame,sapply(seq_along(df[,start]), cross_zero,df=df,start=start,end=end,simplify = F))
}else {
start = 'starting_bars_variable'
df$starting_bars_variable <- stats::ave(df[,end], df[,id], FUN=dplyr::lag)
df$starting_bars_variable[is.na(df$starting_bars_variable)] <- 0
}
#Calculating the length of the bar for that section
temp_end <- df[,end] - as.numeric(as.character(df[,start]))
#Sections that are negative have to have a negative length
temp_end[as.numeric(as.character(df[,start]))<0] <- 0 - temp_end[as.numeric(as.character(df[,start]))<0]
#This column is the length of the bar section. The end column name is used so the x axis has the correct label
df[,end] <- temp_end
df <- data.frame(df)
starting_times <- sort(unique(df[,start]),decreasing = TRUE)
##Negative times need to be in backwards order to stack properly
starting_times[starting_times<0] <- rev(starting_times[starting_times<0])
df[,start] <- factor(df[,start],starting_times)
df[, id] <- factor(df[, id], levels = id_order)
plot <-
ggplot2::ggplot(df) +
ggplot2::geom_col(position = "stack",
ggplot2::aes_string(fill = name_fill,col = name_col,alpha=name_alpha, group = start,x = id, y = end),...) + ggplot2::coord_flip() +
ggplot2::theme_bw(base_size = base_size) +
ggplot2::theme(panel.grid.minor = ggplot2::element_blank(),panel.grid.major = ggplot2::element_blank())
if(!is.null(stratify)) plot <-  plot + ggplot2::facet_wrap(stats::as.formula(paste("~",paste(stratify,collapse = "+"))),scales = "free_y")+
ggplot2::theme(strip.background = ggplot2::element_rect(colour="black", fill="white"))
if(identifiers==FALSE) plot <-  plot + ggplot2::theme(axis.title.y=ggplot2::element_blank(),
axis.text.y=ggplot2::element_blank(),
axis.ticks.y=ggplot2::element_blank())
return(plot)
}
##PLAYING WITH THE ORDER
df <- data.frame(id=c("A","B","C","D","E"),start=c(-5,-4,-3,-2,-1),end=c(-1,-1,-1,-1,-0.5),
col=c(1,1,3,2,2),E=c(1,2,3,4,5))
##PLAYING WITH STRATIFYING
swimmer_plot(df,name_fill='col',id_order=c("A","B","E","C","D"))
swimmer_plot(df,name_fill='col',id_order=c("A","B","E","C","D"),stratify = 'col')
df <- data.frame(id=c("A","A","C","D","E"),end=c(1,2,3,4,5),
col=c(1,5,3,2,2),E=c(1,2,3,4,5))
swimmer_plot(df,name_fill='col',id_order=c("A","B","E","C","D"))
df <- data.frame(id=c("A","B","C","D","E"),end=c(1,2,3,4,5),
col=c("A","A","C","D","E"),E=c(1,2,3,4,5))
swimmer_plot(df,name_fill='col')
swimmer_plot(df,name_fill='col',stratify = "col")
swimmer_plot(df,name_fill='col')
swimmer_plot(df,name_fill='col',stratify = "col")
df <- data.frame(id=c("A","B","C","D","E","E"),end=c(1,2,3,4,5,6),
col=c("A","A","C","D","E","E"))
swimmer_plot(df,name_fill='col')
df <- data.frame(id=c("A","B","C","D","E","E"),end=c(1,2,3,4,5,6),
col=c("A","A","C","D","E","E2"))
swimmer_plot(df,name_fill='col')
swimmer_plot(df,name_fill='col',stratify = "id")
df <- data.frame(id=c("A","B","C","D","E","E"),start=c(0,0,0,0,0,5),end=c(1,2,3,4,5,6),
col=c("A","A","C","D","E","E2"))
swimmer_plot(df,name_fill='col')
swimmer_plot(df,name_fill='col',stratify = "id")
df <- data.frame(id=c("A","B","C","D","E","E"),start=c(0,0,0,0,0,5),end=c(1,2,3,4,5,7),
col=c("A","A","C","D","E","E2"))
swimmer_plot(df,name_fill='col')
swimmer_plot(df,name_fill='col',stratify = "id")
swimmer_plot(df,name_fill='col',id_order=c("A","B","E","C","D"))
df <- data.frame(id=c("A","B","C","D","E","E"),start=c(0,0,0,0,0,6),end=c(1,2,3,4,5,7),
col=c("A","A","C","D","E","E2"))
swimmer_plot(df,name_fill='col')
swimmer_plot(df,name_fill='col',stratify = "id")
df <- data.frame(id=c("A","B","C","D","E","E"),start=c(0,0,0,0,0,6),end=c(1,2,3,4,5,7),
col=c("A","A","C","D","E","E2"))
swimmer_plot(df,name_fill='col')
swimmer_plot(df,name_fill='col',stratify = "id")
df <- data.frame(id=c("A","B","C","D","E","E"),start=c(0,0,0,0,0,5),end=c(1,2,3,4,5,7),
col=c("A","A","C","D","E","E2"))
swimmer_plot(df,name_fill='col',stratify = "id")
id
start
end
col
stratify = "id")
df <- data.frame(id=c("A","B","C","D","E","E"),start=c(0,0,0,0,0,5),end=c(1,2,3,4,5,7),
col=c("A","A","C","D","E","E2"),group=c("A","B","C","D","E","E"))
swimmer_plot(df,name_fill='col',stratify = "group")
df <- data.frame(id=c("A","B","C","D","E","E"),start=c(0,0,0,0,0,6),end=c(1,2,3,4,5,7),
col=c("A","A","C","D","E","E2"),group=c("A","B","C","D","E","E"))
swimmer_plot(df,name_fill='col',stratify = "group")
df <- data.frame(id=c(1,2,3,4,5),start=c(0,0,0,0,0),end=c(1,2,3,4,5))
swimmer_plot(df,name_fill='id')
df <- data.frame(id=c(2,1,3,4,5),start=c(0,0,0,0,0),end=c(1,6,3,4,5))
swimmer_plot(df,name_fill='id')
df <- data.frame(id=c(1,2,3,4,5),start=c(-5,-4,-3,-2,-1),end=c(1,2,3,4,5))
swimmer_plot(df,name_fill='id')
# No changes all positive -------------------------------------------------
df <- data.frame(id=c(1,2,3,4,5),start=c(0,0,0,0,0),end=c(1,2,3,4,5))
# No changes all positive -------------------------------------------------
df <- data.frame(id=c(1,2,3,4,5),start=c(0,0,0,0,0),end=c(1,2,3,4,5),group1=c(5,5,5,10,10),group2=c('A',"B","B","A","C"))
swimmer_plot(df)
##FILL BY ID
swimmer_plot(df,fill='id')
##FILL BY ID
swimmer_plot(df,name_fill='id')
##FILL BY CONTINUOUS
swimmer_plot(df,name_fill='group1')
##FILL BY CATEGORIC
swimmer_plot(df,name_fill='group2')
df
##ALPHA
swimmer_plot(df,name_alpha='group2')
##ALPHA
swimmer_plot(df,name_alpha='group1')
swimmer_plot(df,name_alpha='group2')
##COL
swimmer_plot(df,name_alpha='group2')
##COL
swimmer_plot(df,name_col='group2')
##ORDER BY VARIABLE
swimmer_plot(df,order='group2')
##ORDER BY VARIABLE
swimmer_plot(df,id_order='group2')
##ORDER BY VARIABLE
swimmer_plot(df,id_order='group2',name_fill='group2')
swimmer_plot(df,id_order='group2',increasing = F)
swimmer_plot(df,id_order='group2',increasing = F,name_fill='group2')
##ORDER BY VARIABLE
swimmer_plot(df,id_order='group2',name_fill='group2')
swimmer_plot(df,id_order='group2',increasing = F,name_fill='group2')
##ORDER
swimmer_plot(df,id_order=c(4,5,1,2,3),name_fill='group2')
##STRATIFY
swimmer_plot(df,id_order=c(4,5,1,2,3),name_fill='group2',stratify = 'group1')
##STRATIFY
swimmer_plot(df,id_order=c(4,5,1,2,3),name_fill='group1',stratify = 'group2')
##STRATIFY
swimmer_plot(df,id_order='group2',name_fill='group1',stratify = 'group2')
##STRATIFY
swimmer_plot(df,id_order='group2',name_fill='group2',stratify = 'group2')
##STRATIFY
swimmer_plot(df,id_order='group2',name_fill='group2',stratify = 'group1')
##STRATIFY
swimmer_plot(df,name_fill='group2',stratify = 'group1')
swimmer_plot(df,name_fill='group2',stratify = c('group1','group2'))
df
# No changes all negative, end positive -----------------------------------
df <- data.frame(id=c(1,2,3,4,5),start=c(-5,-4,-3,-2,-1),end=c(1,2,3,4,5),group1=c(5,5,5,10,10),group2=c('A',"B","B","A","C"))
##BASIC
swimmer_plot(df)
##FILL BY ID
swimmer_plot(df,name_fill='id')
##FILL BY CONTINUOUS
swimmer_plot(df,name_fill='group1')
##FILL BY CATEGORIC
swimmer_plot(df,name_fill='group2')
##ALPHA
swimmer_plot(df,name_alpha='group1')
swimmer_plot(df,name_alpha='group2')
##COL
swimmer_plot(df,name_col='group2')
##ORDER BY VARIABLE
swimmer_plot(df,id_order='group2',name_fill='group2')
swimmer_plot(df,id_order='group2',increasing = F,name_fill='group2')
##ORDER BY VARIABLE
swimmer_plot(df,id_order='group2',name_fill='group2')
df
swimmer_plot(df,id_order='group2',increasing = F,name_fill='group2')
##ORDER BY VARIABLE
swimmer_plot(df,id_order='group2',name_fill='group2')
swimmer_plot(df,id_order='group2',increasing = F,name_fill='group2')
##ORDER BY VARIABLE
swimmer_plot(df,id_order='group2',name_fill='group2')
swimmer_plot(df,id_order='group2',increasing = F,name_fill='group2')
##ORDER
swimmer_plot(df,id_order=c(4,5,1,2,3),name_fill='group2')
##COL
swimmer_plot(df,name_col='group2')
##ORDER BY VARIABLE
swimmer_plot(df,id_order='group2',name_fill='group2')
swimmer_plot(df,id_order='group2',increasing = F,name_fill='group2')
##ORDER
swimmer_plot(df,id_order=c(4,5,1,2,3),name_fill='group2')
##STRATIFY
swimmer_plot(df,name_fill='group2',stratify = 'group1')
swimmer_plot(df,name_fill='group2',stratify = c('group1','group2'))
##STRATIFY
swimmer_plot(df,name_fill='group2',stratify = 'group1')
swimmer_plot(df,name_fill='group2',stratify = c('group1','group2'))
df
df <- data.frame(id=c(1,2,3,4,5),start=c(-5,-4,0,1,2),end=c(1,2,3,4,5),col=c(1,2,3,4,5))
swimmer_plot(df,name_fill='start',id_order=c(2,3,1,5,4))
# No changes some positive some negative ----------------------------------
df <- data.frame(id=c(1,2,3,4,5),start=c(-5,-4,0,1,2),end=c(-1,2,3,4,5),col=c(1,2,3,4,5))
# No changes all negative end at zero -------------------------------------
df <- data.frame(id=c(1,2,3,4,5),start=c(-5,-4,-3,-2,-1),end=c(0,0,0,0,0),group1=c(5,5,5,10,10),group2=c('A',"B","B","A","C"))
##BASIC
swimmer_plot(df)
##FILL BY ID
swimmer_plot(df,name_fill='id')
##FILL BY CONTINUOUS
swimmer_plot(df,name_fill='group1')
##FILL BY CATEGORIC
swimmer_plot(df,name_fill='group2')
##ALPHA
swimmer_plot(df,name_alpha='group1')
swimmer_plot(df,name_alpha='group2')
##COL
swimmer_plot(df,name_col='group2')
##ORDER BY VARIABLE
swimmer_plot(df,id_order='group2',name_fill='group2')
swimmer_plot(df,id_order='group2',increasing = F,name_fill='group2')
##ORDER BY VARIABLE
swimmer_plot(df,id_order='group2',name_fill='group2')
swimmer_plot(df,id_order='group2',increasing = F,name_fill='group2')
##COL
swimmer_plot(df,name_col='group2')
swimmer_plot(df,name_col='group2',increasing=T)
swimmer_plot(df,name_col='group2',increasing=F)
